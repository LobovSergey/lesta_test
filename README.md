Добрый день. Добавлю комментарии по поводу каждого задания.

1) Проверка осуществляется через логическое И, путем проверки последнего бита на 0 или 1
Из плюсов можно выделить то, что не осуществляется деление, как один из дорогих по времени операторов, соответсвенно играет роль на время выполнения
Из минусов - неочевидность чтения

2) Реализованы 2 класса - list(second_1)  и односвязный список(second_2). Разница между ними заключается в скорости обработки, т.к. по первому классу сложность составляет O(n) из за операции pop(i),а во втором классе идет O(1). Так же различие в занимаемой памяти. Оба буфера принимают значения,    добавляют в конец очереди и выдают первый элемент по запросу. 

3) quicksort - самый быстрая сортировка по наихудшему сценарию, что является наверно лучшим вариантом - О(n log n), но тут идет большой объем занимаемой памяти из за слияния списков. Так же если учитывать сценарий, в котором элементы в списке уже могут быть упорядочены, то bubblesort - тоже является неплохим вариантом, т.к. в общем по худшему - О(n^2), но возможный лучший сценарий O(n), вдобавок происходящее происходит в самом массиве и по памяти будет занимать O(1)
